// Required global variables
var WEBHOOK_URL = 'https://hooks.slack.com/services/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'; // Replace with your actual Incoming Webhook URL

var TOKEN = 'xoxb-129287844646-6719286728064-pZh3d7YggEWN3zAVgxlC9ifX'; // Slack Bot User OAuth Access Token
var KUDOS_CHANNEL_ID = 'C06M6SRGQE4'; //testing channel ID 
//'C010PUCLQJF'; // #kudos channel ID
var SLIDES_ID = '1fh7R6NJNLYi5dowCblYi78pP0Sc9hDfRKxvOWi3pYsU'; // Google Slides presentation ID
var COLORS = [ // Define five distinct light colors using RGB values for the text boxes
  {red: 255, green: 255, blue: 224}, // Light Yellow
  {red: 144, green: 238, blue: 144}, // Light Green
  {red: 173, green: 216, blue: 230}, // Light Blue
  {red: 255, green: 182, blue: 193}, // Light Pink
  {red: 216, green: 191, blue: 216}  // Light Purple
];

// Handles POST requests from Slack events
function doPost(e) {
  console.log('Received POST request');
  var json = JSON.parse(e.postData.contents);
  console.log('Parsed JSON:', json);

  // Handle verification challenge for Slack Event API
  if (json.type === 'url_verification' && json.challenge) {
    console.log('Handling URL Verification Challenge');
    return ContentService.createTextOutput(json.challenge);
  }
  
  // Security check: verify the token
  if (json.token !== TOKEN) {
    console.log('Invalid token');
    return ContentService.createTextOutput('Invalid token').setMimeType(ContentService.MimeType.TEXT);
  }

  // Check if it's a new message event in the #kudos channel
  if (json.event && json.event.type === 'message' && json.event.channel === KUDOS_CHANNEL_ID) {
    console.log('New message from #kudos channel:', json.event.text);
    // Additional processing...
  } else {
    console.log('Event ignored:', json.event);
  }

  // Default response for logging purposes
  console.log('Sending default response');
  return ContentService.createTextOutput(JSON.stringify({ "response": "Processed or ignored" }))
    .setMimeType(ContentService.MimeType.JSON);
}

function sendAcknowledgmentMessage(channelId, threadTs, messageText) {

  // Prepare the message payload
  // Note: Incoming webhooks do not support threading directly in the same way the API method does,
  // so this message will be posted as a new message to the channel.
  var payload = JSON.stringify({
    text: messageText,
    channel: channelId, // Optional: Specify the channel if your webhook is not restricted to a specific channel
    // To attempt replying in a thread, you can experiment with adding this property,
    // though it's not officially supported in incoming webhooks as of my last update:
    // "thread_ts": threadTs
  });

  var options = {
    method: 'post',
    contentType: 'application/json',
    payload: payload,
    muteHttpExceptions: true // To prevent throwing exceptions for non-2xx responses
  };

  // Send the message
  var response = UrlFetchApp.fetch(WEBHOOK_URL, options);
  var jsonResponse = JSON.parse(response.getContentText());

  // Log the result for debugging
  if (jsonResponse.ok) {
    console.log('Acknowledgment message sent successfully.');
  } else {
    console.log('Failed to send acknowledgment message:', jsonResponse);
  }
}


// Function to create a text box in the Google Slides presentation for a given message
function createTextBoxForMessage(messageText) {
  var presentation = SlidesApp.openById(SLIDES_ID);
  var slide = presentation.getSlides()[0]; // Assuming you're adding to the first slide for simplicity
  var posX = 50; // Fixed position; consider calculating based on existing elements for dynamic placement
  var posY = 50; // Fixed position; adjust as needed
  var textBoxWidth = 400; // Adjust size as needed
  var textBoxHeight = 100; // Adjust size as needed
  var colorIndex = Math.floor(Math.random() * COLORS.length); // Choose a random color
  var color = COLORS[colorIndex];
  
  var textBox = slide.insertTextBox(messageText, posX, posY, textBoxWidth, textBoxHeight);
  textBox.getFill().setSolidFill(rgbToHex(color.red, color.green, color.blue));
  textBox.getText().getTextStyle().setFontSize(10); // Adjust font size as needed
}

function prepareMessageBoxText(message, userInfoMap) {
  var finalText = "";

  // Detect if the message is from KudosBot
  if (message.text.includes('received kudos from')) {
    // Split the message text at the link, assuming the link is the first URL in the message
    // and that the appreciation text ends before the link.
    var linkStartIndex = message.text.search(/<https?:\/\/[^\s]+>/);
    var appreciationText = message.text;
    if (linkStartIndex !== -1) {
      // Extract text up to the link, excluding it and anything that follows
      appreciationText = message.text.substring(0, linkStartIndex).trim();
    }

    // Further split to isolate appreciation text if needed
    var parts = appreciationText.split("\n");
    appreciationText = parts.length > 1 ? parts[1].trim() : appreciationText; // Assuming appreciation text is the second line

    // Extract user names from the remaining text
    var givingUserMatch = appreciationText.match(/from @([^ ]+)/);
    var receivingUserMatch = appreciationText.match(/@([^ ]+) received kudos/);

    if (givingUserMatch && receivingUserMatch) {
      var givingUser = givingUserMatch[1].trim(); // User giving kudos
      var receivingUser = receivingUserMatch[1].trim(); // User receiving kudos

      finalText = `Kudos for: @${receivingUser}\n${parts[parts.length - 1]}\n- @${givingUser}`;
    }
  } else {
    // Handle standard user posts
    var textWithUserNames = message.text.replace(/<@([A-Z0-9]+)>/g, function(match, userId) {
      var userName = userInfoMap[userId] ? userInfoMap[userId] : "Unknown User";
      return "@" + userName;
    });

    var posterName = userInfoMap[message.user] ? userInfoMap[message.user] : "Unknown Poster";
    finalText = `${textWithUserNames}\n- ${posterName}`;
  }

  return finalText;
}

// Fetch user information for all mentioned users in the messages
function fetchUserInfo(messages) {
  var userIds = new Set();
  messages.forEach(message => {
    userIds.add(message.user); // Add user who posted the message
    // Add mentioned users
    var matches = message.text.match(/<@([A-Z0-9]+)>/g);
    if (matches) {
      matches.forEach(match => userIds.add(match.slice(2, -1)));
    }
  });

  var userInfoMap = {};
  userIds.forEach(userId => {
    var userInfoUrl = 'https://slack.com/api/users.info?user=' + userId;
    var options = {
      'headers': {
        'Authorization': 'Bearer ' + TOKEN
      },
      'muteHttpExceptions': true
    };
    var userInfoResponse = UrlFetchApp.fetch(userInfoUrl, options);
    var userInfoJson = JSON.parse(userInfoResponse.getContentText());
    if (userInfoJson.ok) {
      userInfoMap[userId] = userInfoJson.user.real_name || userInfoJson.user.name;
    }
  });
  return userInfoMap;
}

// Creates a text box with a message in the Google Slides presentation
function createColoredTextBoxInPresentation(message, slideIndex) {
  var presentation = SlidesApp.openById(SLIDES_ID);
  var slide = presentation.getSlides()[slideIndex]; // Assuming you're using the first slide (index 0)
  
  // Define slide dimensions (standard 10" x 7.5" for a 4:3 aspect ratio slide)
  var slideWidth = 550; // Width in points
  var slideHeight = 400; // Height in points
  
  // Define text box dimensions
  var textBoxWidth = 100; // Adjust based on your needs
  var textBoxHeight = 100; // Adjust based on your needs
  
  // Generate random position for the text box within the slide boundaries
  // Ensuring the text box doesn't go outside the slide's dimensions
  var posX = Math.random() * (slideWidth - textBoxWidth);
  var posY = Math.random() * (slideHeight - textBoxHeight);
  
  var colorIndex = Math.floor(Math.random() * COLORS.length);
  var color = COLORS[colorIndex];
  
  var textBox = slide.insertTextBox(message, posX, posY, textBoxWidth, textBoxHeight);
  textBox.getFill().setSolidFill(rgbToHex(color.red, color.green, color.blue));
  textBox.getText().getTextStyle().setFontSize(8); // Adjust font size as needed
}

// Helper function to convert RGB values to Hex
function rgbToHex(r, g, b) {
  return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}


//////////////Testing//////////////////////////

function simulateKudosMessagePost() {
  // Simulate a kudos message event payload
  var simulatedEventPayload = {
    token: 'xoxb-129287844646-6719286728064-pZh3d7YggEWN3zAVgxlC9ifX', // Your App's Verification Token
    team_id: 'T0001',
    api_app_id: 'A0001',
    event: {
      type: 'message',
      channel: 'C06M6SRGQE4', // The channel ID for the #kudos channel
      user: 'U2147483697', // Example user ID of the person who posted the message
      text: '@U23456789 Great job on the project! #kudos', // Example kudos message text
      ts: '1355517523.000005',
      event_ts: '1355517523.000005',
      channel_type: 'channel'
    },
    type: 'event_callback',
    event_id: 'Ev0001',
    event_time: 1234567890,
    authed_users: ['U1234567890']
  };

  // Convert the simulated event payload to a format that doPost expects
  var e = {
    postData: {
      contents: JSON.stringify(simulatedEventPayload),
      type: 'application/json'
    }
  };

  // Call the doPost function with the simulated event
  doPost(e);
}
